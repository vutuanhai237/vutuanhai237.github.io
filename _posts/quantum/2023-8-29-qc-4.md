---
layout: post
title: "QML guide #1: Begin"
categories: quantum
link: https://vutuanhai237.github.io/quantum/2023/8/29/qc-4.html
---

### **Giới thiệu**

Quantum machine learning (QML) là chủ đề nghiên cứu giao thoa giữa machine learning và quantum computing.

Vì yêu cầu kiến thức ở cả hai lĩnh vực, nên sẽ tương đối khó nếu chúng ta bắt đầu ở project tầm cao.

Trong post này, mình sẽ hướng dẫn các em nhập môn nghiên cứu về QML thông qua thuật toán Quantum K - nearest neighboor (QKNN). Bài hướng dẫn bao gồm hai phần: lý thuyết cơ sở và thực hành.

### 1. Lý thuyết cơ sở

Các khái niệm cần nắm về machine learning:
- Classification: là bài toán yêu cầu xác định label của một đối tượng chưa biết trước. Ví dụ: Tin nhắn thuộc loại bình thường, quan trọng hay spam.
- Supervised learning: học giám sát.
- Dataset: train set, test set, data point.
- Data point: data, label.
- Noise.

Tài liệu về machine learning:
- [Nhập môn](https://machinelearningcoban.com/2016/12/27/categories/)
- [kNN](https://machinelearningcoban.com/2017/01/08/knn/)

Các khái niệm cần nắm về quantum computing:
- Qubit, quantum state, operator.
- Superposition.
- Quantum gate: Hadamard gate, CNOT gate, SWAP gate, Fredkin gate, Rotation gate.
- Measurement cơ bản (thống kê)

Tài liệu về quantum computing:
- [Sách tiếng việt](https://github.com/vutuanhai237/CourseMaterials/blob/master/BOQC-Basis%20of%20Quantum%20computing/Book/Quantum%20ComputingV2.pdf): chỉ cần đọc chương 1 - 5, bạn nào cần bản giấy có thể qua thư viện UIT hoặc thư viên trung tâm mua / mượn.

### 2. Giới thiệu

#### 2.1. Thuật toán kNN cổ điển

kNN được xếp vào dạng thuật toán machine learning đơn giản nhất, với ý tưởng có thể tóm gọn như sau: "hùa theo số đông, bên cạnh mình như thế nào thì mình sẽ theo vậy".

![image info](https://github.com/vutuanhai237/vutuanhai237.github.io/blob/master/assets/image/quantum-guide/knn.svg?raw=true)

**Input**: chúng ta sẽ được cho trước dataset $D$, có chia thành hai tập nhỏ hơn là train set $D_{train}$ và test set $D_{test}$. Trong đó giả định những data point $d_i$ trong train set có đủ (data, label) còn test set thì data point $d_j$ chỉ có (data).

**Output**: xác định các label của data point trong test set.

**Thuật giải**:

**B1**:
Với mỗi data point $d_j$ trong $D_{test}$:
___Với mỗi data point $d_i$ trong $D_{train}$:
______Tính $dist_{i,j} = distanceFunc(d_i, d_j)$.

*Chú thích*: $distanceFunc$ là hàm tính khoảng cách giữa hai data point bất kỳ. Tuy vào định nghĩa mà đây có thể là hàm Euclidean hoặc cosin.

**B2**: 
Với mỗi data point $d_j$ trong test set $D_{test}$:
___$dist_{j}=[dist_{0,j},dist_{1,j},...,dist_{n_{train},j}]$ với $n_{train}$ là số lượng data point của $D_{train}$.
___Sắp xếp $dist_{j}$ theo thứ tự tăng dần và lấy $k$ data point thuộc $D_{train}$ gần với $d_j$ nhất.
___Lấy ra $k$ label tương ứng, chọn ra label có số lượng nhiều nhất (major vote).
___$d_j.label=majorVote(label_1,label_2,...,label_k$) 

**B3**: Đánh giá hiệu quả của kNN, bước này sẽ được hướng dẫn sau.

*Nhận xét*: chúng ta sẽ chú ý đến B1, thực thi hàm $distanceFunc$ là bước tốn nhiều tài nguyên nhất và toàn bộ B1 có độ phức tạp $\mathcal{O}(n_{train}*n_{test}*n)$ với $n_{train}, n_{test}$ và $n$ lần lượt là số lượng data point trong $D_{train}, D_{test}$ và kích thước data point. Nếu thực thi $distanceFunc$ trên máy tính lượng tử, chúng ta sẽ giảm độ phức tạp xuống được $\mathcal{O}(n_{train}*n_{test}*\log{n})$, cực kì có lợi trong trường hợp $n$ lớn.

*Câu hỏi*:
- Chọn $k$ như thế nào cho hợp lý?
- Chọn $distanceFunc$ như thế nào cho hợp lý?
- Điều kiện của $n_{train}$ và $n_{test}$ như thế nào thì thuật toán mới tiến hành được? 

#### 2.2. SWAP - test circuit.

Hiểu nôm na, đây là một thiết kế mạch có chức năng tính toán khoảng cách giữa hai data point. Phần này khá dài nên các bạn đọc trong paper [này](https://informatica.si/index.php/informatica/article/view/3608).

**Input**: $d_i$ và $d_j$.
**Output**: là một số thực, khoảng cách giữa $d_i$ và $d_j$.

*Câu hỏi*:
- Làm sao để đưa $d_i$ và $d_j$ vào mạch lượng tử?
- SWAP-test hoạt động như thế nào (viết chuỗi phương trình biến đổi trạng thái).
- Làm sao để mạch lượng tử trả về kết quả (viết phương trình toán tử đo tác động lên trạng thái).

#### 2.3. Quantum kNN

Nếu như các bạn đã hiểu hai phần 2.1 và 2.2 thì phần này đơn giản là chúng ta thay thế $B1$ trong phần 2.1 bằng mạch lượng tử trong phần 2.2.

Lúc này, nếu nhìn tổng quan, mô hình của chúng ta sẽ có kiến trúc như sau:

![image info](https://github.com/vutuanhai237/vutuanhai237.github.io/blob/master/assets/image/quantum-guide/hybrid.svg?raw=true)

Đây chính là một trong những mô hình phổ biến trong quantum machine learning, chúng ta sẽ bám theo mô hình này trong khoảng thời gian về sau.

Tham khảo:

[1] M. Schuld and F. Petruccione, Machine learning with quantum computers (Springer, 2021).
 